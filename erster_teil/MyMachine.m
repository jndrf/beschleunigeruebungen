(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["MyMachine`"]


(* ::Input::Initialization:: *)
$ContextPath


(* ::Input::Initialization:: *)
$Context


(* ::Input::Initialization:: *)
drift::usage=
"drift[L]: produces the 6x6 matrix of a drift space with length L"   


(* ::Input::Initialization:: *)
addr56::usage=
"addr56[dummy,r56]: adds an element r56 to the existing matrix"   


(* ::Input::Initialization:: *)
dipol::usage=
"dipol[L,\[Rho]]: produces the 6x6 matrix of a sector dipol with length L and bending radius \[Rho]"   


(* ::Input::Initialization:: *)
quad::usage=
"quad[L,k]: produces the 6x6 matrix of a sector quadrupol with length L and parameter k. Positiv k : vertically focussing, Negative k : horizontally focussing"   


(* ::Input::Initialization:: *)
skewquad::usage=
"skewquad[L,k,\[Phi]]: produces the 6x6 matrix of a quadrupol with length L and parameter k rotated by skew angle \[Phi]. Positiv k : vertically focussing, Negative k : horizontally focussing"   


(* ::Input::Initialization:: *)
thinlens::usage=
"thinlens[0,f]: produces the 6x6 matrix of thin lens with focal lens f and -f horizontally and vertically"   


(* ::Input::Initialization:: *)
combfun::usage=
"combfun[L,\[Rho],k]: produces the 6x6 matrix of a sector combined function magnet with length L, bending radius \[Rho] and parameter k. Positiv k : vertically focussing, Negative k : horizontally focussing"   


(* ::Input::Initialization:: *)
sext::usage=
"sext[L,ml]: sextupoles are treated as drift spaces in matrix calculations. They are taken into acount in tracking. This adds a sextupol of integrated strength m*L=ml and lenghth L."   


(* ::Input::Initialization:: *)
oct::usage=
"oct[L,rl]: octupoles are treated as drift spaces in matrix calculations. They are taken into acount in tracking. This adds a octupol of integrated strength r*L=rl and lenghth L."     


(* ::Input::Initialization:: *)
dipkick::usage=
"dipkick[L,kk]: adds a horizontal dipol kick of strength kk mrad.They should have length 0 and are only regarded in tracking"     


(* ::Input::Initialization:: *)
quadkick::usage=
"quadkick[L,kl]: adds a quadrupol kick of strength kl*x and -kl*z .They should have length 0 and are only regarded in tracking"       


(* ::Input::Initialization:: *)
kanteGen::usage=
"kanteGen[dummy,\[Rho],\[Psi]]: produces the 6x6 matrix of the edge of a magnet with bending radius \[Rho] and deflection angle \[Psi]"   


(* ::Input::Initialization:: *)
kante::usage=
"kante[dummy,\[Rho],\[Psi]]: identical to kanteGen[ ] " 


(* ::Input::Initialization:: *)
kanteRect::usage=
"kanteRect[dummy,l,\[Rho]]: produces the 6x6 matrix of the edge of a rectangular dipol-magnet with bending radius \[Rho] and arclength l"   


(* ::Input::Initialization:: *)
makelattice::usage=
"makelattice[cell_List,endpoint]: produces the 6x6 matrix of a lattice of anz repetitions of the elements of the cell list from s=0 to the endpoint"   


(* ::Input::Initialization:: *)
matrix::usage=
"matrix[cell_List]: produces the 6x6 matrix of a lattice including all elements"   


(* ::Input::Initialization:: *)
stable::usage=
"stable[cell_List]: checks stability assuming the cell list as periodic structure"   


(* ::Input::Initialization:: *)
magvalslist::usage=
"magvalslist[cell_List]:extracts the strength and s boundaries of magnets. The type of magnet can be specified as an option, default is magtype->quad. The result is given als list of {strength,{smin,smax}} pairs."   


(* ::Input::Initialization:: *)
track::usage=
"track[params_List,endpoint,startvector]: tracks the startvector through the lattice defined by the params from s=0 to the endpoint.The params are given als {anz,{cell_List}}, the result is {endpoint,{newvector}}. "   


(* ::Input::Initialization:: *)
relphaseperiod::usage="relphaseperiod[cell_List,npoints_:100]: calculates horizontal and vertical phase advance through the periodic lattice by integrating 1/\[Beta](s). The result is given as interpolating functions.  "


(* ::Input::Initialization:: *)
tracklin::usage=
"trackwith[params_List,endpoint,startvector]: tracks the startvector through the lattice defined by the params from s=0 to the endpoint.The params are given als {anz,{cell_List}}, the result is {endpoint,{newvector}}. "   


(* ::Input::Initialization:: *)
Xablage::usage=
"Xablage[list]: picks out the x values from a result list in the form {{s1,x1},{s2,x2}...}."   


(* ::Input::Initialization:: *)
Yablage::usage=
"Yablage[list]: picks out the z values from a result list in the form {{s1,z1},{s2,z2}...}."   


(* ::Input::Initialization:: *)
Xprime::usage=
"Xprime[list]: picks out the x\[OpenCurlyQuote] values from a result list in the form {{s1,x1'},{s2,x2'}...}."   


(* ::Input::Initialization:: *)
Zprime::usage=
"Zprime[list]: picks out the z\[OpenCurlyQuote] values from a result list in the form {{s1,z1'},{s2,z2'}...}."   


(* ::Input::Initialization:: *)
Xphase::usage=
"Xphase[list]: picks out the {x,x\[OpenCurlyQuote]} pairs from a result list in the form {{x1,x1'},{x2,x2'}...}."   


(* ::Input::Initialization:: *)
Sphase::usage=
"Sphase[list]: picks out the {\[Delta]s,\[Delta]p/p} pairs from a result list."   


(* ::Input::Initialization:: *)
Spos::usage=
"Spos[list]: picks out the {x,\[Delta]s} pairs from a result list in the form {{x1,\[Delta]s1'},{x2,\[Delta]s2'}...}."   


(* ::Input::Initialization:: *)
Yphase::usage=
"Yphase[list]: picks out the {z,z\[OpenCurlyQuote]} pairs from a result list in the form {{z1,z1'},{z2,z2'}...}."   


(* ::Input::Initialization:: *)
Tplane::usage=
"Tplane[list]: picks out the {x,z} pairs from a result list in the form {{x1,z1},{x2,z2}...}."   


(* ::Input::Initialization:: *)
PlotBeamdist::usage=
"PlotBeamdist[list_List,n_Integer,m_Integer]:make plots of beam particle distributions in list. The iables are indexed as usual :\n
1 : x\n
2 : x'\n
3 : y\n
4 : y'\n
5 : \[Delta]s\n
6 : \[Delta]p\n 
The longitudinal coordinate s is indexed as 0."   


(* ::Input::Initialization:: *)
PlotYphase::usage=
"PlotYphase[list]: makes the z-phase plot for the data in list. "   


(* ::Input::Initialization:: *)
PlotXphase::usage=
"PlotXphase[list]: makes the x-phase plot for the data in list."   


(* ::Input::Initialization:: *)
PlotYablage::usage=
"PlotYablage[list]: makes the z-Ablage plot for the data in list."   


(* ::Input::Initialization:: *)
PlotXablage::usage=
"PlotXablage[list]: makes the x-Ablage plot for the data in list."   


(* ::Input::Initialization:: *)
PlotXprime::usage=
"PlotXprime[list]: makes the x' plot for the data in list."   


(* ::Input::Initialization:: *)
PlotZprime::usage=
"PlotZprime[list]: makes the z' plot for the data in list."   


(* ::Input::Initialization:: *)
PlotSpos::usage=
"PlotSpos[list]: makes the \[Delta]s plot for the data in list."   


(* ::Input::Initialization:: *)
PlotTplane::usage=
"PlotTplane[list]: makes the plot of transverse coordinates for the data in list."   


(* ::Input::Initialization:: *)
PlotSphase::usage=
"PlotSphase[list]: makes the plot of \[Delta]s - \[Delta]p/p coordinates for the data in list."   


(* ::Input::Initialization:: *)
PlotSXphase::usage=
"PlotSXphase[list]: makes the plot of \[Delta]s - x coordinates for the data in list."   


(* ::Input::Initialization:: *)
PlotShisto::usage=
"PlotShisto[list]: makes the plot of \[Delta]s as Histogram."   


(* ::Input::Initialization:: *)
getlength::usage=
"getlength[list,printon:True]: determines the length of a specific cell and ring.If printon is set False, no printout is produced. It Returns {cell length,total length}. "   


(* ::Input::Initialization:: *)
getEmittance::usage=
"getEmittance[list]: determines the statistical emittance of in both transverse planes. "   


(* ::Input::Initialization:: *)
getCoiance::usage=
"getEmittance[list]: determines the statistical coiance matrix in both transverse planes. "   


(* ::Input::Initialization:: *)
periodbetafuns::usage=
"periodbetafuns[cell_List,endpoint_]: calculates the periodic betatron functions at position s=endpoint for a circular machine in the form of {s,{\!\(\*SubscriptBox[\(\[Beta]\), \(x\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(x\)]\),\!\(\*SubscriptBox[\(\[Gamma]\), \(x\)]\),\[Eta]},{\!\(\*SubscriptBox[\(\[Beta]\), \(y\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(y\)]\),\!\(\*SubscriptBox[\(\[Gamma]\), \(y\)]\),\[Eta]'},\!\(\*SubscriptBox[\(\[Mu]\), \(h\)]\),\!\(\*SubscriptBox[\(\[Mu]\), \(v\)]\)} . "


(* ::Input::Initialization:: *)
plotPeriodbetafuns::usage=
"plotPeriodbetafuns[cell_List,showelements_True]: plots the optical functions for a circular machine... "


(* ::Input::Initialization:: *)
trackbetafuns::usage=
"trackbetafuns[betain_List,cell_List,endpoint_]: tracks the beta functions through a lattice. The betafunctions are given and returned as {s,{\!\(\*SubscriptBox[\(\[Beta]\), \(x\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(x\)]\),\!\(\*SubscriptBox[\(\[Gamma]\), \(x\)]\),D},{\!\(\*SubscriptBox[\(\[Beta]\), \(y\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(y\)]\),\!\(\*SubscriptBox[\(\[Gamma]\), \(y\)]\),D'},\!\(\*SubscriptBox[\(\[Phi]\), \(h\)]\),\!\(\*SubscriptBox[\(\[Phi]\), \(v\)]\)} . "


(* ::Input::Initialization:: *)
getQ::usage=
"getQ[cell_List]: calculates horizontal and vertical Q values. Form : {\!\(\*SubscriptBox[\(\[Mu]\), \(h\)]\),\!\(\*SubscriptBox[\(Q\), \(h\)]\),\!\(\*SubscriptBox[\(\[Mu]\), \(v\)]\),\!\(\*SubscriptBox[\(Q\), \(v\)]\)}. The Q values are the fractional Q values only.  "


(* ::Input::Initialization:: *)
getChroma::usage=
"getChroma[cell_List]:  "


(* ::Input::Initialization:: *)
getQLinCoup::usage=
"getQLinCoup[cell_List]: calculates the two Q values including linear coupling.  Form : {\!\(\*SubscriptBox[\(\[Mu]\), \(1\)]\),\!\(\*SubscriptBox[\(Q\), \(1\)]\),\!\(\*SubscriptBox[\(\[Mu]\), \(2\)]\),\!\(\*SubscriptBox[\(Q\), \(2\)]\)}. The Q values are the fractional Q values only. Notice that they cannot be attributed to the horizontal or vertical plane.  "


(* ::Input::Initialization:: *)
makerandombeam::usage=
"makerandombeam[npoints] generates a set of random beam points according to optic parameters and emittances specified as Options. It accepts the optic parameters as output of periodbetafuns." 


(* ::Input::Initialization:: *)
makefixepsbeam::usage=
"makefixepsbeam[npoints_,opticpar_List,eps_List,longpar_List:{0,0}]: makes a set of particles according to optic parameters and emittances distributed along a full phase rotation (an ellipse). It accepts the optic parameters as output of periodbetafuns or in the format {{\[Beta]h,\[Alpha]h},{\[Beta]v,\[Alpha]v}}. " 


(* ::Input::Initialization:: *)
tfellipsoid::usage=
"tfellipsoid[transfermatrix_List,initialparams_List] calculates the new matrix of the ellipsoid (6x6) resulting from the transfermatrix.
The initialvalues can be specified \!\(\*
StyleBox[\"either\",\nFontWeight->\"Plain\"]\) as transverse \[Beta]-functions only, that is {{\!\(\*SubscriptBox[\(\[Beta]\), \(h\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(h\)]\)},{\!\(\*SubscriptBox[\(\[Beta]\), \(v\)]\),\!\(\*SubscriptBox[\(\[Alpha]\), \(v\)]\)}} or as the full 6x6 matrix.  "


(* ::Input::Initialization:: *)
plotTransEllipses::usage=
"plotTransEllipses[ellipsoid_List,emittances_List:{1.,1.}] draws the transverse phase space ellipses"


(* ::Input::Initialization:: *)
addsexkick::usage=
"addsexkick[m_,startvec_]: adds a sextupole kick for a sextupole strength of m to each element of the startvectors list"


(* ::Input::Initialization:: *)
addquadkick::usage=
"addquadkick[k_,startvec_]: adds a sextupole kick for a quadrupol strength of k to each element of the startvectors list"


(* ::Input::Initialization:: *)
addoctkick::usage=
"addoctkick[r_,startvec_]: adds a octupole kick for a octupole strength of r to each element of the startvectors list"


(* ::Input::Initialization:: *)
plotelements::usage=
"plotelements[opt_List]:  "


(* ::Input::Initialization:: *)
plotlenses::usage=
"plotelements[opt_List]:  "


(* ::Input::Initialization:: *)
pmod::usage=
"mod[optics_List,\[Delta]_]: modifies quads and dipols according to the relative momentum deviation \[Delta]"


(* ::Input::Initialization:: *)
expand::usage="expand[cell_List]: repeats the cell n-times, n being the first argument in cell "


(* ::Input::Initialization:: *)
clearInOut::usage="clearInOut[]: clears all In and Out cells to save memory. "


(* ::Input::Initialization:: *)
UniPlot2D::usage="Uniplot2D[data_List,{xaxis_String,scalex_String},{yaxis_String,scaley_String},opts]: a generell function to plot phasespace quantities. Uses Plot[] options for illustration."


(* ::Input::Initialization:: *)
Begin["`Private`"]


(* ::Input::Initialization:: *)
Print["Version 17.12.2017"]


(* ::Input::Initialization:: *)
$RecursionLimit=\[Infinity]


(* ::Input::Initialization:: *)
clearInOut[_] = Module[{},Unprotect[In,Out];Clear[In,Out];Protect[In,Out];
]


(* ::Input::Initialization:: *)

dipolBrown[L_,\[Rho]_] = {{Cos[kx L],1/kx*Sin[kx L],0,0,0,h/kx^2(1-Cos[kx L])},{-kx*Sin[kx L],Cos[kx L],0,0,0,h/kx Sin[kx L]},{0,0,Cos[ky L],1/ky*Sin[ky L],0,0},{0,0,-ky*Sin[ky L],Cos[ky L],0,0},{h/kx Sin[kx L],h/kx^2(1-Cos[kx L]),0,0,1,h^2/kx^3(kx L - Sin[kx L])},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)


dipolBX[L_,\[Rho]_] = Limit[dipolBrown[L,\[Rho]] //. {h->1/\[Rho],kx->h},ky->0]


(* ::Input::Initialization:: *)
dipol[L_,\[Rho]_]={{Cos[L/\[Rho]],\[Rho] Sin[L/\[Rho]],0,0,0,\[Rho] (1-Cos[L/\[Rho]])},{-(Sin[L/\[Rho]]/\[Rho]),Cos[L/\[Rho]],0,0,0,Sin[L/\[Rho]]},{0,0,1,L,0,0},{0,0,0,1,0,0},{-Sin[L/\[Rho]],-\[Rho] (1-Cos[L/\[Rho]]),0,0,1,-\[Rho] (L/\[Rho]-Sin[L/\[Rho]])},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
quadfinal[L_,k_] = Limit[dipolBrown[L,\[Rho]] //. {kx->Sqrt[k],ky->Sqrt[-k]},h->0]


(* ::Input::Initialization:: *)
quad[L_,k_] = If[L==0,thinlens[0,k],
quadfinal[L,k]] 


(* ::Input::Initialization:: *)
mrot[\[Phi]_] = {{Cos[\[Phi]],0,Sin[\[Phi]],0,0,0},{0,Cos[\[Phi]],0,Sin[\[Phi]],0,0},{-Sin[\[Phi]],0,Cos[\[Phi]],0,0,0},{0,-Sin[\[Phi]],0,Cos[\[Phi]],0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
skewquad[L_,k_,\[Phi]_] = mrot[-\[Phi]].quad[L,k]. mrot[\[Phi]]//FullSimplify


(* ::Input::Initialization:: *)
combfun[L_,\[Rho]_,k_] = Simplify[dipolBrown[L,\[Rho]] //. {h->1/\[Rho],kx->Sqrt[(1-n)]h,ky->Sqrt[n] h,n-> k \[Rho]^2},\[Rho]>0]


(* ::Input::Initialization:: *)
thinlens[L_,f_] = {{1,L,0,0,0,0},{-1/f,1,0,0,0,0},{0,0,1,0,0,0},{0,0,1/f,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
drift[L_] = {{1,L,0,0,0,0},{0,1,0,0,0,0},{0,0,1,L,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
sext[L_,m_] = {{1,L,0,0,0,0},{0,1,0,0,0,0},{0,0,1,L,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
oct[L_,m_] = {{1,L,0,0,0,0},{0,1,0,0,0,0},{0,0,1,L,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
dipkick[L_,m_] = {{1,L,0,0,0,0},{0,1,0,0,0,0},{0,0,1,L,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
quadkick[L_,kl_] = {{1,L,0,0,0,0},{0,1,0,0,0,0},{0,0,1,L,0,0},{0,0,0,1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
addr56[dummy_,r56_] = {{1,0,0,0,0,0},{0,1,0,0,0,0},{0,0,1,0,0,0},{0,0,0,1,0,0},{0,0,0,0,1,r56},{0,0,0,0,0,1}} 


(* ::Input::Initialization:: *)
kanteGen[dummy_,\[Rho]_,\[Psi]_]={{1,0,0,0,0,0},{Tan[\[Psi]]/\[Rho],1,0,0,0,0},{0,0,1,0,0,0},{0,0,-Tan[\[Psi]]/\[Rho],1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
kante[dummy_,\[Rho]_,\[Psi]_]={{1,0,0,0,0,0},{Tan[\[Psi]]/\[Rho],1,0,0,0,0},{0,0,1,0,0,0},{0,0,-Tan[\[Psi]]/\[Rho],1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
kanteRect[dummy_,l_,\[Rho]_]={{1,0,0,0,0,0},{Tan[l/(2\[Rho])]/\[Rho],1,0,0,0,0},{0,0,1,0,0,0},{0,0,-Tan[l/(2\[Rho])]/\[Rho],1,0,0},{0,0,0,0,1,0},{0,0,0,0,0,1}}


(* ::Input::Initialization:: *)
stable[cellin_List]:= Module[{resmat,npercell,ntot,elements,lengthlist,bounds,circum,fullturns,partlength,forw,nlast,nfull,diag,prodmat,mat,format,restlength,npart,cell,cellmat,trh,trv,stab},

mat= matrix[cellin];
trh = Tr[mat[[1;;2,1;;2]]];
trv = Tr[mat[[3;;4,3;;4]]];
stab=trh<= 2 && trh >= -2 &&trv<= 2 && trv >= -2;
Return[stab];
]


(* ::Input::Initialization:: *)
matrix[cellin_List]:=Module[{resmat,npercell,ntot,elements,lengthlist,bounds,circum,fullturns,partlength,forw,nlast,nfull,diag,prodmat,mat,format,restlength,npart,cell,cellmat,anz},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
npercell = Length[cell];
ntot = npercell*anz;
elements = cell;
elements = Reverse[elements];

ClearAll[prodmat];
diag =DiagonalMatrix[{1,1,1,1,1,1}];
prodmat[0]=diag;
mat[n_] :=elements[[n,1]][Sequence@@Rest[elements[[n]]]];
prodmat[n_]:=mat[Mod[n-1,npercell]+1].prodmat[n-1] ;
cellmat = prodmat[npercell];
Return[cellmat];
]


(* ::Input::Initialization:: *)
makelattice[cellin_List,endpoint_]:=Module[{resmat,npercell,ntot,elements,lengthlist,bounds,circum,fullturns,partlength,forw,nlast,nfull,diag,prodmat,mat,format,restlength,npart,cell,cellength,anz,fullcells,cellmat,fullmat,lpart,lastfullelemat,parmat},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
npercell = Length[cell];

ntot = npercell*anz;
elements = cell;
elements = Reverse[elements];
lengthlist = Map[Take[#,{2,2}]&,elements]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
circum = cellength*anz;
(*endpoint = nturns*circum*);
(*Print[endpoint]*);
fullturns = Floor[endpoint/circum];
fullcells = Floor[endpoint/cellength];

(*Anzahl der komplett durchlaufenen Zellen*);
partlength = endpoint-fullcells*cellength;
(* das ist die Strecke innerhalb der letzten nicht mehr vollen Zelle *);
cellmat = matrix[Reverse[elements]];
fullmat = MatrixPower[cellmat,fullcells];
If[partlength==0,
resmat = fullmat,

forw = Select[bounds,# <=partlength&];

nlast= Length[forw];

(* das ist die Anzahl der noch ganzen Elemente in der letzten Zelle *);
nfull = fullturns*ntot+nlast-1;

ClearAll[prodmat];
diag =DiagonalMatrix[{1,1,1,1,1,1}];
prodmat[0]=diag;
mat[n_] :=elements[[n,1]][Sequence@@Rest[elements[[n]]]];
(*wir rechnen modulo der Zellenl\[ADoubleDot]nge, was man nicht aber nicht ben\[ODoubleDot]tigt wenn man nur maximal eine Zelle rechnet...
prodmat macht also genau so viele Matrizen (maximal) wie die Zelle Elemente hat, immer vom Beginn der Zelle bis zum Ende diesen Elements *);
prodmat[n_]:=mat[Mod[n-1,npercell]+1].prodmat[n-1] ;
(*cellmat = prodmat[npercell];*)
(* das sind jetzt alle voll durchlaufenen Zellen *);
restlength = If[Length[forw]>0,Last[forw],0];

(*die Restl\[ADoubleDot]nge ganzer Elemente in der letzten angebrochenen Zelle*);
npart = nlast;

lpart = partlength-restlength;

lastfullelemat = prodmat[npart-1];

(*die Nummer des angebrochenen Elements und die L\[ADoubleDot]nge darin und die Matrix der noch ganzen Elemente*);
(*Print[fullturns," voll Uml.  ",nlast-1," full elements  ",lpart," inside  ",elements[[npart,1]]]*);
(*jetzt machen wir die spezielle Matrix f\[UDoubleDot]r das leztzte Element mit der Restl\[ADoubleDot]nge*);
If[lpart>0,parmat = elements[[npart,1]][lpart,Sequence@@Drop[elements[[npart]],2]],parmat=diag];

resmat = parmat.lastfullelemat.fullmat//Chop
];
Return[{endpoint,resmat}];
]


(* ::Input::Initialization:: *)
makelength[cellin_List,printon_:True,pc_:1.]:=Module[{npercell,ntot,cell,lengthlist,p1list,p2list,namelist,getfactor,p3list,bounds,newlist,headlist,cellength,totlength,anz},

If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];

npercell = Length[cell];
ntot = npercell*anz;
cell = Reverse@Map[PadRight[#,4]&,cell];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
p1list = Map[Take[#,{3,3}]&,cell]//Flatten;
p2list = Map[Take[#,{4,4}]&,cell]//Flatten;
namelist = Map[Take[#,{1,1}]&,cell]//Flatten;
getfactor[elem_List]:= Switch[elem[[1]],quad,elem[[3]]*pc/0.2998,dipol,elem[[3]]*0.2998/pc,_,elem[[3]]];
p3list = getfactor /@ cell;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
newlist = Thread[List[namelist,lengthlist,p1list,p3list,p2list,Rest[bounds]]];
headlist = {{"type","length","strength","at "<>ToString[pc]<>" GeV","add.par","end position"}};
cellength = Last[bounds];
totlength = cellength*anz;

If[printon,Print[Grid[Join[headlist,newlist],Frame->All,Alignment->{Left,Center},Background->{None,{1->Pink}}]];
Print["L\[ADoubleDot]nge der Zelle ",cellength," m ,Gesamtl\[ADoubleDot]nge ",totlength," m"];
];

Return[{cellength,totlength}];
];


(* ::Input::Initialization:: *)
Options[magvalslist]= {Global`magtype->quad}


(* ::Input::Initialization:: *)
magvalslist[cellin_List, opts:OptionsPattern[]]:=Module[{},

If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
npercell = Length[cell];
ntot = npercell*anz;
mtyp= OptionValue[Global`magtype];
cell = Reverse@Map[PadRight[#,4]&,cell];
(* now all elements have 4 entries *)
pquad = First /@ Position[cell,mtyp];
(* the positions of the quadrupoles in the list *)
kstrength =Part[#,3]& /@ cell[[pquad]];
(* the strengths of the quadrupoles in the list *)
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;

bounds = FoldList[Plus,0,lengthlist]//Flatten;
pbounds = Partition[bounds,2,1];
klims = pbounds[[pquad]];
result = Thread[List[kstrength,klims]];
Return[result];
];


(* ::Input::Initialization:: *)
Options[getChroma]= {Global`withdipols->True,Global`natural->True}


(* ::Input::Initialization:: *)
getChroma[cellin_,opts:OptionsPattern[]]:= Module[{cell,bfuns,\[Beta]h,\[Beta]v,\[Eta]\[Beta]x,\[Eta]\[Beta]y,anz,ixquad,iyquad,iysext,ixsext,ixdipols,getks,get\[Rho]s,getms,cx,cy},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
cell = cell /. thinlens -> quad;
bfuns= periodbetafuns[cell];
\[Beta]h[s_?NumericQ]:= bfuns[s][[2,1,1]];
\[Beta]v[s_?NumericQ]:= bfuns[s][[2,2,1]];
\[Eta]\[Beta]x[s_?NumericQ]:=(bfuns[s][[2,1,4]])*(bfuns[s][[2,1,1]]);
\[Eta]\[Beta]y[s_?NumericQ]:=(bfuns[s][[2,1,4]])*(bfuns[s][[2,2,1]]);
ixquad[argu_List] := If[argu[[2,1]]==argu[[2,2]],\[Beta]h[argu[[2,1]]]/argu[[1]],
NIntegrate[\[Beta]h[s],{s,argu[[2,1]],argu[[2,2]]}]*argu[[1]]];
iyquad[argu_List] :=  If[argu[[2,1]]==argu[[2,2]],\[Beta]v[argu[[2,1]]]/(-argu[[1]]),NIntegrate[\[Beta]v[s],{s,argu[[2,1]],argu[[2,2]]}]*(-argu[[1]])];
iysext[argu_List] :=  If[argu[[2,1]]==argu[[2,2]],\[Eta]\[Beta]y[argu[[2,1]]]*(-argu[[1]]),NIntegrate[\[Eta]\[Beta]y[s],{s,argu[[2,1]],argu[[2,2]]}]*(-argu[[1]])];
ixsext[argu_List] := If[argu[[2,1]]==argu[[2,2]],-\[Eta]\[Beta]x[argu[[2,1]]]*argu[[1]],NIntegrate[-\[Eta]\[Beta]x[s],{s,argu[[2,1]],argu[[2,2]]}]*(argu[[1]])];
ixdipols[argu_List] := NIntegrate[\[Beta]h[s],{s,argu[[2,1]],argu[[2,2]]}]*(2/argu[[1]]^2);
getks =magvalslist[cell,magtype->quad];
get\[Rho]s =magvalslist[cell,magtype->dipol];
getms =magvalslist[cell,magtype->sext];
cx = If[OptionValue[Global`withdipols],
-1/(4 \[Pi])*(Total[ixquad  /@ getks]+Total[ixdipols  /@ get\[Rho]s]),
-1/(4 \[Pi])*Total[ixquad  /@ getks]
];
cy = -1/(4 \[Pi])*Total[iyquad  /@ getks];
If[!OptionValue[Global`natural],
cx=cx+1/(4 \[Pi])*Total[ixsext /@ getms];
cy=cy-1/(4 \[Pi])*Total[iysext /@ getms]
];
Return[{cx,cy}]
]


(* ::Input::Initialization:: *)
plotelements[cellin_List,ylims_List:{0,0}]:=Module[{npercell,namelist,bounds,cellength,diplist,driftlist,dipols,drifts,thinlist,thin,quadlist,sextlist,yup,ydown,quads,sexts,graph,anz,cell,lengthlist,dipcolor=Directive[Opacity[0.5],Hue[1]],FQcolor=Directive[Opacity[0.5],Hue[0.7]],SPcolor=Directive[Opacity[0.5],Yellow],SMcolor=Directive[Opacity[0.5],Gray],DQcolor=Directive[Opacity[0.5],Hue[0.3]],driftcolor=Directive[Opacity[0.5],RGBColor[1,1,1]]},

If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];

npercell = Length[cell];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
namelist = Map[Take[#,{1,1}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
diplist = Position[cell,_?(!AtomQ[#] && #[[1]]==dipol|| !AtomQ[#] && #[[1]]==dipolrect&),1]//Flatten;
driftlist = Position[cell,_?(!AtomQ[#] && #[[1]]==drift&),1]//Flatten;
quadlist = Position[cell,_?(!AtomQ[#] && #[[1]]==quad&),1]//Flatten;
sextlist = Position[cell,_?(!AtomQ[#] && #[[1]]==sext&),1]//Flatten;
thinlist = Position[cell,_?(!AtomQ[#] && #[[1]]==thinlens&),1]//Flatten;

If[ylims[[1]]==0 && ylims[[2]]==0,yup = cellength/20.;
ydown = 0.;
,yup=ylims[[2]];
ydown=ylims[[1]];
];

dipols = Graphics[{dipcolor,Table[Rectangle[{bounds[[diplist[[n]]]],ydown},{bounds[[diplist[[n]]+1]],yup}],{n,1,Length[diplist]}]}];
quads = Graphics[{Table[{Switch[Sign[cell[[quadlist[[n]],3]]],1,FQcolor,-1,DQcolor],Rectangle[{bounds[[quadlist[[n]]]],ydown},{bounds[[quadlist[[n]]+1]],yup}]},{n,1,Length[quadlist]}]}];
sexts = Graphics[{Table[{Switch[Sign[cell[[sextlist[[n]],3]]],1,SPcolor,-1,SMcolor],Rectangle[{bounds[[sextlist[[n]]]],ydown},{bounds[[sextlist[[n]]]]+yup/10.,yup}]},{n,1,Length[sextlist]}]}];
thin = Graphics[{Table[{Switch[Sign[cell[[thinlist[[n]],3]]],1,FQcolor,-1,DQcolor],Rectangle[{bounds[[thinlist[[n]]]],ydown},{bounds[[thinlist[[n]]]]+yup/10.,yup}]},{n,1,Length[thinlist]}]}];
drifts = Graphics[{driftcolor,Table[Rectangle[{bounds[[driftlist[[n]]]],ydown},{bounds[[driftlist[[n]]+1]],yup}],{n,1,Length[driftlist]}]}];

graph  = Legended[Show[{dipols,quads,drifts,thin,sexts},AspectRatio->Automatic],SwatchLegend[{dipcolor,FQcolor,DQcolor,SPcolor,SMcolor},{"Dipols","F-Quad","D-Quad","S+","S-"}]];
Return[graph];
];


(* ::Input::Initialization:: *)
plotlenses[cellin_List,ylims_List:{0,0}]:=Module[{npercell,namelist,bounds,cellength,diplist,driftlist,quadlist,dipols,quads,drifts,anz,cell,lengthlist,thinlist,thin,dipolgraph,dipcolor=Directive[Opacity[0.5],Hue[1]],FQcolor=Directive[Opacity[0.5],Hue[0.7]],DQcolor=Directive[Opacity[0.5],Hue[0.3]],driftcolor=Directive[Opacity[0.0],RGBColor[1,1,1]],flens,dlens,yoff,ysc,graph},If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz=1;cell=cellin];npercell=Length[cell];lengthlist=Map[Take[#,{2,2}]&,cell]//Flatten;namelist=Map[Take[#,{1,1}]&,cell]//Flatten;bounds=FoldList[Plus,0,lengthlist]//Flatten;cellength=Last[bounds];diplist=Position[cell,_?(!AtomQ[#]&&#[[1]]==dipol||!AtomQ[#]&&#[[1]]==dipolrect&),1]//Flatten;driftlist=Position[cell,_?(!AtomQ[#]&&#[[1]]==drift&),1]//Flatten;
quadlist=Position[cell,_?(!AtomQ[#]&&#[[1]]==quad&),1]//Flatten;
thinlist = Position[cell,_?(!AtomQ[#] && #[[1]]==thinlens&),1]//Flatten;

flens[x_,y_,scale_]:={Point[{x,y}],Circle[{x,y}-{16/4scale,y},17/4scale,{ArcSin[1/3],-ArcSin[1/3]}],Circle[{x,y}+{16/4scale,y},17/4scale,{ArcSin[1/3]-\[Pi],-ArcSin[1/3]-\[Pi]}]};dlens[x_,y_,scale_]:={Point[{x,y}],Circle[{x,y}-{18/4scale,y},17/4scale,{ArcSin[1/3],-ArcSin[1/3]}],Circle[{x,y}+{18/4scale,y},17/4scale,{ArcSin[1/3]-\[Pi],-ArcSin[1/3]-\[Pi]}],Line[{{x-scale/2.05,0.464scale/Sin[1/3]},{x+scale/2.05,0.464scale/Sin[1/3]}}],Line[{{x-scale/2.05,-0.464scale/Sin[1/3]},{x+scale/2.05,-0.464scale/Sin[1/3]}}]};dipolgraph[x_,y_,ld_,scale_]:={EdgeForm[Red],White,Rectangle[{x-ld/2,y-scale},{x+ld/2,y+scale}]};If[ylims[[1]]==0&&ylims[[2]]==0,ysc=cellength/20.;yoff=0.;,ysc=ylims[[2]];yoff=ylims[[1]];];
dipols=Graphics[{dipcolor,Table[dipolgraph[(bounds[[diplist[[n]]]]+bounds[[diplist[[n]]+1]])/2.,yoff,(bounds[[diplist[[n]]]]-bounds[[diplist[[n]]+1]]),ysc],{n,1,Length[diplist]}]}];
quads=Graphics[{Table[Switch[Sign[cell[[quadlist[[n]],3]]],1,flens[(bounds[[quadlist[[n]]]]+bounds[[quadlist[[n]]+1]])/2.,yoff,ysc],-1,dlens[(bounds[[quadlist[[n]]]]+bounds[[quadlist[[n]]+1]])/2.,yoff,ysc]],{n,1,Length[quadlist]}]}];
thin=Graphics[{Table[Switch[Sign[cell[[thinlist[[n]],3]]],1,flens[(bounds[[thinlist[[n]]]]+bounds[[thinlist[[n]]+1]])/2.,yoff,ysc],-1,dlens[(bounds[[thinlist[[n]]]]+bounds[[thinlist[[n]]+1]])/2.,yoff,ysc]],{n,1,Length[thinlist]}]}];
drifts = Graphics[{driftcolor,Table[Rectangle[{bounds[[driftlist[[n]]]],-ysc},{bounds[[driftlist[[n]]+1]],ysc}],{n,1,Length[driftlist]}]}];
graph=Show[{dipols,quads,drifts,thin,Graphics@Line[{{0,0},{cellength,0}}]},AspectRatio->Automatic];
Return[graph];
];


(* ::Input::Initialization:: *)
Options[getlength] = {PrintList->False,pc->1.}


(* ::Input::Initialization:: *)
getlength[params_List,opts:OptionsPattern[]] :=makelength[params,OptionValue[PrintList],OptionValue[pc]];


(* ::Input::Initialization:: *)
tfellipsoid[matrix_List,initialvalues_List]:=Block[{initgiven, inmat,resmat,tmat},
initgiven::unknownarg = "initial ellipsoid matrix not in known format. See usage note.";
tmat::unknowformat = "Unknown format of transfer matrix.";
initgiven = Switch[Dimensions[initialvalues],{2,2},1,{6,6},2,_,Message[initgiven::unknownarg,initialvalues];3];
inmat = Switch[initgiven,1,With[{\[Beta]h = initialvalues[[1,1]],\[Alpha]h= initialvalues[[1,2]],\[Beta]v= initialvalues[[2,1]],\[Alpha]v= initialvalues[[2,2]]},
{{\[Beta]h,-\[Alpha]h,0,0,0,0},{-\[Alpha]h,(1+\[Alpha]h^2)/\[Beta]h,0,0,0,0},{0,0,\[Beta]v,-\[Alpha]v,0,0},{0,0,-\[Alpha]v,(1+\[Alpha]v^2)/\[Beta]v,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0}}],
2,initialvalues,3,DiagonalMatrix[{1,1,1,1,1,1}]];
tmat = Switch[Dimensions[matrix],{2},matrix[[2]],{6,6},matrix,_,Message[tmat::unknownformat,matrix];DiagonalMatrix[{1,1,1,1,1,1}]];
resmat = tmat.inmat.Transpose[tmat] ;
Return[resmat]
];


(* ::Input::Initialization:: *)
relphaseperiod[cellin_List,anzpoints_:100]:=Module[{cell,resmat,lengthlist,bounds,cellength,endnew,nfullcells,stepwidth,tab,tabh,tabv,\[Phi],\[Phi]fun,anz},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz=1;cell=cellin];
lengthlist=Map[Take[#,{2,2}]&,cell]//Flatten;
bounds=FoldList[Plus,0,lengthlist]//Flatten;
cellength=Last[bounds];
stepwidth = cellength/anzpoints;
tab = Table[periodbetafuns[cell,s],{s,0,cellength,stepwidth}];
tabh = 1/tab[[All,2,1,1]];
tabv = 1/tab[[All,2,2,1]];

\[Phi] = Thread[List[Range[0.,cellength,stepwidth],Thread[List[Accumulate[tabh]*stepwidth,Accumulate[tabv]*stepwidth]]]];

\[Phi]fun = Interpolation[\[Phi],InterpolationOrder->1];

Return[\[Phi]fun];]



(* ::Input::Initialization:: *)
periodbetafuns::symbolarg="The argument `1` is not not numeric.";


(* ::Input::Initialization:: *)
periodbetafuns::symbollength="optics has non-numerical length specifications";


(* ::Input::Initialization:: *)
periodbetafuns[cellin_List] := Module[{cell,resmat,lengthlist,bounds,cellength,rematcell,submath,submatv,endnew,cellmat,bmat,muh,muv,nennh,nennv,checkh,checkv,betah,betav,alphah,alphav,gammah,gammav,eta,endpoint,numtest,anz,cmuh,smuh,cmuv,smuv,etaprime},

If[IntegerQ[cellin[[1]]],anz=cellin[[1]];
cell=cellin[[2]];
,anz = 1;
cell=cellin;
];
\[Beta]start = periodbetafuns[cellin,0];
result = trackbetafuns[\[Beta]start,cellin];
Return[result]
];


(* ::Input::Initialization:: *)
periodbetafuns[cellin_List,endin_ ] := Module[{cell,resmat,lengthlist,bounds,cellength,rematcell,submath,submatv,endnew,cellmat,bmat,muh,muv,nennh,nennv,checkh,checkv,betah,betav,alphah,alphav,gammah,gammav,eta,endpoint,numtest,anz,cmuh,smuh,cmuv,smuv,etaprime},

If[!NumberQ[endin],Message[periodbetafuns::symbolarg,endin];Return[]];

endpoint=endin;
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];
cell=cellin[[2]];
,anz = 1;
cell=cellin;
];

numtest = Map[NumericQ ,cell,{2}][[All,2]];
If[MemberQ[numtest,False] && endpoint!= 0,Message[periodbetafuns::symbollength];Return[]];
cellmat = matrix[cell];
If[endpoint==0,
bmat = cellmat,
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
endnew = Mod[endpoint,cellength];
resmat = makelattice[cell,endnew][[2]];
(*cellmat = makelattice[cell,cellength][[2]]*);

bmat =resmat.cellmat.Inverse[resmat];
];
cmuh = 1/2*(cellmat[[1,1]]+cellmat[[2,2]]);
smuh = Sqrt[1-cmuh^2];
muh = ArcCos[cmuh];
cmuv = 1/2*(cellmat[[3,3]]+cellmat[[4,4]]);
smuv = Sqrt[1-cmuv^2];
muv = ArcCos[cmuv];
betah = Abs[bmat[[1,2]]]/smuh;
betav = Abs[bmat[[3,4]]]/smuv;
alphah = (bmat[[1,1]]-bmat[[2,2]])/(2 smuh);
alphav = (bmat[[3,3]]-bmat[[4,4]])/(2 smuv);
gammah = (1+alphah^2)/betah;
gammav = (1+alphav^2)/betav;
eta = ((1-bmat[[2,2]])*bmat[[1,6]]+bmat[[1,2]]*bmat[[2,6]])/(2-bmat[[1,1]]-bmat[[2,2]]);
etaprime = (bmat[[2,1]]*bmat[[1,6]]+(1-bmat[[1,1]])*bmat[[2,6]])/(2-bmat[[1,1]]-bmat[[2,2]]);
Return[Chop[{endpoint,{{betah,alphah,gammah,eta},{betav,alphav,gammav,etaprime},muh,muv}}]]
];


(* ::Input::Initialization:: *)
Options[plotPeriodbetafuns]={Global`showElements->False,Global`showAlpha->True,Global`showEtaprime->False,Global`showPhaseadvance->False,Global`np->100}


(* ::Input::Initialization:: *)
plotPeriodbetafuns[cellin_List,opts:OptionsPattern[]]:=Module[{betah,betav,alphah,alphav,gammah,gammav,eta,showelems,npoins,etaprime,p1,p2,p3,p4,bounds,npoints,lengthlist,cellength,ss,slist,betalist,phasefuns,\[Phi]range,\[Eta]range,pelems1,pelems2,pelems3,pelems4,cell,anz,\[Beta]range,\[Alpha]range,final},
showelems = OptionValue[Global`showElements];
npoints = OptionValue[Global`np];
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
ss= cellength/npoints;
slist = Range[0.,cellength,ss];
betalist = periodbetafuns[cellin,#]& /@ slist;
betah = Interpolation[Thread[List[slist,betalist[[All,2,1,1]]]],InterpolationOrder->1];
alphah = Interpolation[Thread[List[slist,betalist[[All,2,1,2]]]],InterpolationOrder->1];
gammah = Interpolation[Thread[List[slist,betalist[[All,2,1,3]]]],InterpolationOrder->1];
betav = Interpolation[Thread[List[slist,betalist[[All,2,2,1]]]],InterpolationOrder->1];
alphav = Interpolation[Thread[List[slist,betalist[[All,2,2,2]]]],InterpolationOrder->1];
gammav = Interpolation[Thread[List[slist,betalist[[All,2,2,3]]]],InterpolationOrder->1];
eta = Interpolation[Thread[List[slist,betalist[[All,2,1,4]]]],InterpolationOrder->1];
etaprime = Interpolation[Thread[List[slist,betalist[[All,2,2,4]]]],InterpolationOrder->1];
p1 = Plot[{betah[s],betav[s]},{s,0,cellength},AxesLabel->{"s [m]","\[Beta] [m]"},PlotLegends->Placed[LineLegend[{"horizontal","vertical"}, LegendLayout->"Row"],Above],PlotStyle->{Black,Red},PlotRange->{0,Automatic},ImageSize->300];
\[Beta]range = PlotRange/. AbsoluteOptions[p1,PlotRange];
p2 = Plot[{alphah[s],alphav[s]},{s,0,cellength},AxesLabel->{"s [m]","\[Alpha]"},PlotLegends->Placed[LineLegend[{"horizontal","vertical"}, LegendLayout->"Row"],Above],PlotStyle->{Black,Red},ImageSize->300];
\[Alpha]range =PlotRange /. AbsoluteOptions[p2,PlotRange];
If[ OptionValue[Global`showEtaprime],
p3 = Plot[{eta[s],etaprime[s]},{s,0,cellength},AxesLabel->{"s [m]","\[Eta] [m]"},PlotLegends->Placed[LineLegend[{"\[Eta]","\[Eta]'"}, LegendLayout->"Row"],Above],PlotRange->Automatic,PlotStyle->{Black},ImageSize->300],
p3 = Plot[eta[s],{s,0,cellength},AxesLabel->{"s [m]","\[Eta] [m]"},PlotLegends->Placed[LineLegend[{"Dispersion"}, LegendLayout->"Row"],Above],PlotRange->Automatic,PlotStyle->{Black},ImageSize->300]];
If[ OptionValue[Global`showPhaseadvance],
phasefuns =relphaseperiod[cellin]; 
p4 = Plot[{phasefuns[s][[1]],phasefuns[s][[2]]},{s,0,cellength},AxesLabel->{"s [m]","\[Phi]"},PlotLegends->Placed[LineLegend[{"\!\(\*SubscriptBox[\(\[Phi]\), \(x\)]\)","\!\(\*SubscriptBox[\(\[Phi]\), \(y\)]\)"}, LegendLayout->"Row"],Above],PlotRange->Automatic,PlotStyle->{Black,Red},ImageSize->300];
\[Phi]range =PlotRange /. AbsoluteOptions[p4,PlotRange]];
\[Eta]range =PlotRange /. AbsoluteOptions[p3,PlotRange];

If[showelems,pelems1 = plotelements[cellin,\[Beta]range[[2]]/10];pelems2 = plotelements[cellin,\[Alpha]range[[2]]/10];pelems3 = plotelements[cellin,\[Eta]range[[2]]/10];
If[ OptionValue[Global`showPhaseadvance],pelems4 = plotelements[cellin,\[Phi]range[[2]]/10]];
p1=Show[p1,pelems1];
p2=Show[p2,pelems2];
p3=Show[p3,pelems3];
If[ OptionValue[Global`showPhaseadvance],p4 = Show[p4,pelems4]]
];
final =If[OptionValue[Global`showAlpha],
If[ OptionValue[Global`showPhaseadvance],Grid[{{p1,p2},{p3,p4}}],Grid[{{p1},{p2},{p3}}]],
If[ OptionValue[Global`showPhaseadvance],Grid[{{p1},{p3},{p4}}],Grid[{{p1},{p3}}]]]; 
Return[final];
];


(* ::Input::Initialization:: *)
trackbetafuns[betain_List,cellin_List,npoints_:100] := Module[{cell,anz,lengthlist,bounds,cellength,\[Beta]hlist,\[Beta]vlist,stepwidth,endpoint,resmat,hmat,hm3,vmat,\[Beta],\[Alpha],\[Gamma],d,dp,\[CapitalSigma],\[Beta]vnew,\[Beta]hnew,x,y,dvec,dvecnew,tabh,tabv,\[Phi]h,\[Phi]v,\[Phi]funh,\[Phi]funv,\[Beta]hfun,\[Beta]vfun,resfun},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];
cell=cellin[[2]];
,anz = 1;
cell=cellin;
];
cell = expand[cell];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
\[Beta]hlist = Array[0&,npoints];
\[Beta]vlist = Array[0&,npoints];
\[Beta]hlist[[1]]= {0,betain[[2,1]]};
\[Beta]vlist[[1]]= {0,betain[[2,2]]};
stepwidth = cellength/npoints;
Do[
endpoint = stepwidth*n;
resmat = makelattice[cell,endpoint][[2]];
(* horizontal 2x2 matrix *)
hmat = resmat[[1;;2,1;;2]];
(* the 3x3 matrix for dispersion propagation *)
hm3 =ArrayPad[hmat,{{0,1},{0,1}}];
hm3[[1,3]] = resmat[[1,6]];
hm3[[2,3]] = resmat[[2,6]];
hm3[[3,3]] =1.;
(* vertical 2x2 matrix *)
vmat = resmat[[3;;4,3;;4]];
(* extracting the horizontal \[Beta]-function list *)
{Subscript[\[Beta], x],Subscript[\[Alpha], x],Subscript[\[Gamma], x],d}=betain[[2,1]];
(* extracting the vertical \[Beta]-function list *)
{Subscript[\[Beta], y],Subscript[\[Alpha], y],Subscript[\[Gamma], y],dp}=betain[[2,2]];
(* definition of the \[CapitalSigma] matrices *)
\[CapitalSigma][x_]:= {{Subscript[\[Beta], x],-Subscript[\[Alpha], x]},{-Subscript[\[Alpha], x],Subscript[\[Gamma], x]}};
(* the new \[CapitalSigma] matrices after the transportation *) 
\[Beta]vnew = vmat.\[CapitalSigma][y].Transpose[vmat];
\[Beta]hnew = hmat.\[CapitalSigma][x].Transpose[hmat];
(* the dispersion vector *) 
dvec = {d,dp,1};
dvecnew = hm3.dvec;
(* constructing lists for interpolation *)
\[Beta]hlist[[n+1]] = {endpoint,{\[Beta]hnew[[1,1]],-\[Beta]hnew[[1,2]],\[Beta]hnew[[2,2]],dvecnew[[1]]}};
\[Beta]vlist[[n+1]] = {endpoint,{\[Beta]vnew[[1,1]],-\[Beta]vnew[[1,2]],\[Beta]vnew[[2,2]],dvecnew[[2]]}},
{n,1,npoints-1}] ;
(* now the phase advance through integrating 1/\[Beta] *) 
tabh = 1/\[Beta]hlist[[All,2,1]];
tabv = 1/\[Beta]vlist[[All,2,1]];

\[Phi]h = Thread[List[Range[0.,cellength-stepwidth,stepwidth],Accumulate[tabh]*stepwidth]];
\[Phi]v = Thread[List[Range[0.,cellength-stepwidth,stepwidth],Accumulate[tabv]*stepwidth]];

\[Phi]funh = Interpolation[\[Phi]h,InterpolationOrder->1];
\[Phi]funv = Interpolation[\[Phi]v,InterpolationOrder->1];

\[Beta]hfun = Interpolation[\[Beta]hlist,InterpolationOrder->1];
\[Beta]vfun = Interpolation[\[Beta]vlist,InterpolationOrder->1];
(* composing the final function to return *) 
resfun = Function[x,{x,{\[Beta]hfun[x],\[Beta]vfun[x],\[Phi]funh[x],\[Phi]funv[x]}}];
Return[resfun]
];


(* ::Input::Initialization:: *)
getQ[cellin_List] := Module[{anz,cellmat,lengthlist,bounds,cellength,muh,muv,qh,qv,cell},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
cellmat = makelattice[cell,cellength][[2]];
muh = ArcCos[1/2*(cellmat[[1,1]]+cellmat[[2,2]])]//Chop;
muv = ArcCos[1/2*(cellmat[[3,3]]+cellmat[[4,4]])]//Chop;
qh =anz*muh/(2\[Pi]);
qv =anz*muv/(2\[Pi]);

(*Print["Anzahl Zellen  "<>ToString[anz]<>" horizontal: \[Mu] = "<>ToString[muh]<>"  Q = "ToString[qh]<>"\n vertikal: \[Mu] = "<>ToString[muv]<>"  Q = "<>ToString[qv]]*);
Return[{muh,qh,muv,qv}]
];


(* ::Input::Initialization:: *)
getQLinCoup[cellin_List] := Module[{anz,cellmat,lengthlist,bounds,cellength,muh,muv,qh,qv,cell,smat,ematsymtrans,det,tra,trb,mu1,mu2,q1,q2},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
cellmat = makelattice[cell,cellength][[2]];
smat = {{0,-1},{1,0}};
ematsymtrans = - smat.cellmat[[1;;2,3;;4]];
det = Det[ematsymtrans + cellmat[[3;;4,1;;2]]];
tra = (cellmat[[1,1]]+cellmat[[2,2]]);
trb = (cellmat[[3,3]]+cellmat[[4,4]]);
mu1 = ArcCos[1/4*(tra + trb + Sqrt[(tra-trb)^2+4 det])]//Chop;
mu2 =ArcCos[1/4*(tra + trb - Sqrt[(tra-trb)^2+4 det])]//Chop;
q1=anz*mu1/(2\[Pi]);
q2 =anz*mu2/(2\[Pi]);

(*Print["Anzahl Zellen  "<>ToString[anz]<>" horizontal: \[Mu] = "<>ToString[muh]<>"  Q = "ToString[qh]<>"\n vertikal: \[Mu] = "<>ToString[muv]<>"  Q = "<>ToString[qv]]*);
Return[{mu1,q1,mu2,q2}]
];


(* ::Input::Initialization:: *)
expand[cellin_List] := Module[{anz,outlist,cell},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
outlist = Flatten[Table[cell,{n,1,anz}],1];
Return[outlist]
];


(* ::Input::Initialization:: *)
Options[makerandombeam]={Global`betafunctions->{{0.,{1.,0.,1.,1},{1.,0.,1.,1},1.,1.}},Global`emittances->10^-6*{1.,1.},Global`momentumspread->0.,Global`longitudinalspread->0,Global`\[CapitalDelta]x->0.,Global`\[CapitalDelta]x'->0.,Global`\[CapitalDelta]y->0.,Global`\[CapitalDelta]y'->0.,Global`\[CapitalDelta]s->0,Global`\[CapitalDelta]p->0,Global`longcorrelation->0,Global`matchdispersion->False}


(* ::Input::Initialization:: *)
makerandombeam[npoints_,opts:OptionsPattern[]]:=Module[{disth,distv,transpar,eps,longpar,offsets,check,horopt,\[Beta]h,\[Beta]v,\[Alpha]h,\[Alpha]v,\[Gamma]h,\[Gamma]v,\[Epsilon]h,\[Epsilon]v,disp,dispprime,math,matv,endpoint,relds,reldp,longcorr,matlong,vertopt,res,means,zeros,dpvalues,distlong,dispoff,values,out},
transpar = OptionValue[Global`betafunctions];
eps =OptionValue[Global`emittances];
longpar = {OptionValue[Global`longitudinalspread],OptionValue[Global`momentumspread],OptionValue[Global`longcorrelation]}; 
offsets = {{OptionValue[Global`\[CapitalDelta]x],OptionValue[Global`\[CapitalDelta]x']},{OptionValue[Global`\[CapitalDelta]y],OptionValue[Global`\[CapitalDelta]y']},{OptionValue[Global`\[CapitalDelta]s],OptionValue[Global`\[CapitalDelta]p]}};
check = Length[transpar[[1]]];
Switch[check, 
0,horopt =transpar[[2,1]];vertopt = transpar[[2,2]],
2,horopt = transpar[[1]];vertopt = transpar[[2]],
4,horopt = transpar[[1]];vertopt = transpar[[2]],
_,Print["unknown form of parameters"];Return[]
];

\[Beta]h = horopt[[1]];
\[Beta]v =  vertopt[[1]];
\[Alpha]h =  horopt[[2]];
\[Alpha]v = vertopt[[2]];
\[Epsilon]h = eps[[1]];
\[Epsilon]v = eps[[2]];
\[Gamma]h = (1+\[Alpha]h^2)/\[Beta]h;
\[Gamma]v= (1+\[Alpha]v^2)/\[Beta]v;
disp = horopt[[4]];
dispprime = vertopt[[4]];

math = {{\[Beta]h,-\[Alpha]h},{-\[Alpha]h,\[Gamma]h}};


matv = {{\[Beta]v,-\[Alpha]v},{-\[Alpha]v,\[Gamma]v}};

endpoint = 0;

relds = longpar[[1]];
reldp = longpar[[2]];
longcorr = longpar[[3]];
matlong = {{relds,longcorr},{longcorr,reldp}}; (* hier ist keine Korrelation, sprich chirp, vorgesehen *)
disth = RandomReal[MultinormalDistribution[offsets[[1]],\[Epsilon]h*math],npoints];
distv = RandomReal[MultinormalDistribution[offsets[[2]],\[Epsilon]v*matv],npoints];


res = Which[longpar[[1]]==0 && longpar[[2]]==0,

means = Table[offsets[[3]],{npoints}];
Flatten[#,1]& /@ Thread[List[disth,distv,means]],


longpar[[1]]==0 && longpar[[2]]!=0,

zeros = Table[0.,{npoints}];
dpvalues = RandomReal[NormalDistribution[offsets[[3,2]],reldp],npoints];
distlong = Thread[List[zeros,dpvalues]];

If[OptionValue[Global`matchdispersion],dispoff = Times[#,{disp,dispprime}]& /@ dpvalues;
disth = disth + dispoff];

 Flatten[#,1]& /@ Thread[List[disth,distv,distlong]],


longpar[[1]]!=0 && longpar[[2]]==0,

zeros = Table[0.,{npoints}];
values = RandomReal[NormalDistribution[offsets[[3,1]],relds],npoints];
distlong = Thread[List[values,zeros]];
 Flatten[#,1]& /@ Thread[List[disth,distv,distlong]],

longpar[[1]]!=0 && longpar[[2]]!=0,

distlong = RandomReal[MultinormalDistribution[offsets[[3]],matlong],npoints];
dpvalues = distlong[[All,2]];
If[OptionValue[Global`matchdispersion],dispoff = Times[#,{disp,dispprime}]& /@ dpvalues;
disth = disth + dispoff];

res = Flatten[#,1]& /@ Thread[List[disth,distv,distlong]]];
out = Map[List[endpoint,#]&,res];
Return[out];
]


(* ::Input::Initialization:: *)
makefixepsbeam[npoints_,transpar_List,eps_List,longpar_List:{0,0}]:=Module[{},
check = Length[transpar[[1]]];
Switch[check, 
0,horopt =transpar[[2,1]];vertopt = transpar[[2,2]],
2,horopt = transpar[[1]];vertopt = transpar[[2]],
4,horopt = transpar[[1]];vertopt = transpar[[2]],
_,Print["unknown form of parameters"];Return[]
];
If[Length[eps]!=2,Print["please specify \!\(\*SubscriptBox[\(\[Epsilon]\), \(h\)]\) and \!\(\*SubscriptBox[\(\[Epsilon]\), \(v\)]\)"];Return];
\[Beta]h = horopt[[1]];
\[Beta]v =  vertopt[[1]];
\[Alpha]h =  horopt[[2]];
\[Alpha]v = vertopt[[2]];
\[Epsilon]h = eps[[1]];
\[Epsilon]v = eps[[2]];
\[Gamma]h = (1+\[Alpha]h^2)/\[Beta]h;
\[Gamma]v= (1+\[Alpha]v^2)/\[Beta]v;

endpoint = 0;
relds = longpar[[1]];
reldp = longpar[[2]];


res = Table[{Sqrt[\[Epsilon]h \[Beta]h]Cos[\[Psi]],-Sqrt[\[Epsilon]h/\[Beta]h]\[Alpha]h Cos[\[Psi]]-Sqrt[\[Epsilon]h/\[Beta]h] Sin[\[Psi]],Sqrt[\[Epsilon]v \[Beta]v]Cos[\[Psi]],-Sqrt[\[Epsilon]v/\[Beta]v]\[Alpha]v Cos[\[Psi]]-Sqrt[\[Epsilon]v/\[Beta]v] Sin[\[Psi]],relds,reldp} /. \[Psi]->n/npoints*2\[Pi],{n,1,npoints}];

out = Map[List[endpoint,#]&,res];
Return[out];
]


(* ::Input::Initialization:: *)
getbeamsize[cellin_List,eps_List,point_]:=Module[{perh,perv,sizeh,sizev},
perh = periodbetafuns[cellin,point][[2,1]];
perv = periodbetafuns[cellin,point][[2,2]];
sizeh = Sqrt[perh[[1]]*eps[[1]]]//Chop;
sizev = Sqrt[perv[[1]]*eps[[2]]]//Chop;
Return[{sizeh,sizev}];
]


(* ::Input::Initialization:: *)
Options[plotTransEllipses]= Join[{Global`OnePlot->False,Global`NormOptics->{{1,0},{1,0}}},Options[ContourPlot]];


(* ::Input::Initialization:: *)
plotTransEllipses[ellipsoidmat_List,{\[Epsilon]h_,\[Epsilon]v_},opts:OptionsPattern[]]:= Block[{math,matv,pl,\[Beta]hnorm,\[Alpha]hnorm,\[Beta]vnorm,\[Alpha]vnorm,normh,normv,plrange,hbound,vbound,xrange,xprange},
 math = ellipsoidmat[[1;;2,1;;2]];matv =ellipsoidmat[[3;;4,3;;4]];

\[Beta]hnorm = OptionValue[Global`NormOptics][[1,1]];
\[Alpha]hnorm = OptionValue[Global`NormOptics][[1,2]];
\[Beta]vnorm = OptionValue[Global`NormOptics][[2,1]];
\[Alpha]vnorm = OptionValue[Global`NormOptics][[2,2]];
normh = Inverse@{{Sqrt[1/\[Beta]hnorm],0},{\[Alpha]hnorm/Sqrt[\[Beta]hnorm],Sqrt[\[Beta]hnorm]}};
normv = Inverse@{{Sqrt[1/\[Beta]vnorm],0},{\[Alpha]vnorm/Sqrt[\[Beta]vnorm],Sqrt[\[Beta]vnorm]}};

plrange = If[OptionValue[Global`NormOptics]=={{1,0},{1,0}},Full,{{-1.5,1.5},{-1.5,1.5}}];

hbound = (Inverse@normh).{Sqrt[\[Epsilon]h*math[[1,1]]],Sqrt[(1+math[[1,2]])^2 \[Epsilon]h/math[[1,1]]]};
vbound =(Inverse@normv).{Sqrt[\[Epsilon]v*matv[[1,1]]],Sqrt[(1+matv[[1,2]])^2 \[Epsilon]v/matv[[1,1]]]};

Print[{Sqrt[\[Epsilon]h*math[[1,1]]],Sqrt[(1-math[[1,2]])^2 \[Epsilon]h/math[[1,1]]]},"  ",{Sqrt[\[Epsilon]v*matv[[1,1]]],Sqrt[(1-matv[[1,2]])^2 \[Epsilon]v/matv[[1,1]]]}];

{xrange,xprange} ={ 1.5*Max[hbound[[1]],vbound[[1]]],1.5*Max[hbound[[2]],vbound[[2]]]};

If[OptionValue[Global`OnePlot],
pl = ContourPlot[{(normh.{x,xp}).Inverse[math].(normh.{x,xp})==\[Epsilon]h,normv.{x,xp}.Inverse[matv].normv.{x,xp}==\[Epsilon]v},
{x,-xrange,xrange},{xp,-xprange,xprange},Evaluate[FilterRules[{opts}, Options[ContourPlot]]],FrameLabel->{"u","u'"}, AspectRatio->1, PlotRange->plrange],
pl =GraphicsGrid[{ {ContourPlot[{(normh.{x,xp}).Inverse[math].(normh.{x,xp})==\[Epsilon]h},
{x,-xrange,xrange},{xp,-xprange,xprange},Evaluate[FilterRules[{opts}, Options[ContourPlot]]]],ContourPlot[{normv.{x,xp}.Inverse[matv].normv.{x,xp}==\[Epsilon]v},
{x,-xrange,xrange},{xp,-xprange,xprange},Evaluate[FilterRules[{opts}, Options[ContourPlot]]]]}}]];
Return[pl]
]


(* ::Input::Initialization:: *)
tracklin[params_List,endpoint_,startvecin_List] :=Module[{nvecs,mat,out,startvec,res},

(*check: start vector output from tracking result*)
If[Last[Dimensions[startvecin]]==2,startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],If[Length[Dimensions[startvecin]]==1,startvec = {startvecin},startvec = startvecin];
];
mat= makelattice[params,endpoint][[2]];
(*check: start vector single particle*);
nvecs = If[Length[Dimensions[startvec]]==2,Dimensions[startvec][[1]],1;
];
res = Map[Dot[mat,#]&,startvec];
out = Map[List[endpoint,#]&,res];

Return[Chop[out]];
]


(* ::Input::Initialization:: *)
  track[cellin_List,endpoint_,startvecin_List] :=Module[{nvecs,mat,out,res,mhere,subcell,bounds,nkicks,cell,sextlist,octlist,dipkicklist,quadkicklist,allkicks,truekick,startvec,anz,npercell,ntot,lengthlist,cellength,totlength,nturns,quadlist,result,octtlist,addfixkick},

(*check: start vector output from tracking result*)
If[Last[Dimensions[startvecin]]==2,startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],If[Length[Dimensions[startvecin]]==1,startvec = {startvecin},startvec = startvecin];
];
(*check: single cell*);
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];
cell=cellin[[2]];
,anz = 1;
cell=cellin;
];
(*check: start vector single particle*);
nvecs = If[Length[Dimensions[startvec]]==2,Dimensions[startvec][[1]],1;
];
npercell = Length[cell];
ntot = npercell*anz;
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];
totlength = cellength*anz;
nturns = Floor[endpoint/totlength];
cell = expand[{anz*nturns,cell}];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
quadlist = Position[cell,_?(!AtomQ[#] && #[[1]]==quad&),1]//Flatten;
sextlist = Position[cell,_?(!AtomQ[#] && #[[1]]==sext&),1]//Flatten;
octlist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==oct&),1]//Flatten;
dipkicklist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==dipkick&),1]//Flatten;
quadkicklist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==quadkick&),1]//Flatten;

allkicks = Join[sextlist,octlist,dipkicklist,quadkicklist];

nkicks = Length[allkicks];

If[nkicks ==0,result = tracklin[cellin, endpoint, startvecin];
Return[result],

subcell= Take[cell,allkicks[[1]]];

mat= makelattice[subcell,bounds[[allkicks[[1]]]]][[2]];
res = Table[mat.startvec[[n]],{n,1,nvecs}];

mhere = Part[cell,allkicks[[1]],3];
truekick = Which[Length[Cases[sextlist,allkicks[[1]]]]>0,addsexkick,
Length[Cases[octtlist,allkicks[[1]]]]>0,addoctkick,
Length[Cases[dipkicklist,allkicks[[1]]]]>0,addfixkick,
Length[Cases[quadkicklist,allkicks[[1]]]]>0,addquadkick
];
res=Flatten[Map[Take[#,{2}]&,truekick[mhere,res]],1];



Do[subcell = Take[cell,{allkicks[[ns-1]],allkicks[[ns]]}];
mat= makelattice[subcell,bounds[[allkicks[[ns]]]]-bounds[[allkicks[[ns-1]]]]][[2]];
res = Table[mat.res[[n]],{n,1,nvecs}];
mhere = Part[cell,allkicks[[ns]],3];

truekick = Which[Length[Cases[sextlist,allkicks[[ns]]]]>0,addsexkick,
Length[Cases[octtlist,allkicks[[ns]]]]>0,addoctkick,
Length[Cases[dipkicklist,allkicks[[ns]]]]>0,addfixkick,
Length[Cases[quadkicklist,allkicks[[ns]]]]>0,addquadkick
];

res=Flatten[Map[Take[#,{2}]&,truekick[mhere,res]],1];

,{ns ,2,nkicks}];
If[allkicks[[nkicks]] < Length[cell],subcell = Take[cell,{allkicks[[nkicks]]+1,Length[cell]}];
If[Length[subcell]==1 && subcell[[1,1]]==0,Null, mat= makelattice[subcell,endpoint-bounds[[allkicks[[nkicks]]]]][[2]];
res = Table[mat.res[[n]],{n,1,nvecs}];
];
];

out = Map[List[endpoint,#]&,res];
Return[Chop[out]];
];
]


(* ::Input::Initialization:: *)
  trackmanyturns[cellin_List,endpoint_,startvecin_List] :=Module[{nvecs,mat,out,res,mhere,subcell,bounds,nkicks,cell,sextlist,octlist,dipkicklist,quadkicklist,allkicks,truekick,startvec,anz,npercell,ntot,lengthlist,cellength,nturns,quadlist,result,totlength,octtlist,addfixkick},
If[IntegerQ[startvecin[[1,1]]],startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],startvec = startvecin];
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];cell=cellin[[2]],anz = 1;cell=cellin];
nvecs = If[Length[Dimensions[startvec]]==2,Dimensions[startvec][[1]],1];
npercell = Length[cell];
ntot = npercell*anz;
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
cellength = Last[bounds];totlength = cellength*anz;
nturns = Floor[endpoint/totlength];
cell = expand[{anz*nturns,cell}];
lengthlist = Map[Take[#,{2,2}]&,cell]//Flatten;
bounds = FoldList[Plus,0,lengthlist]//Flatten;
quadlist = Position[cell,_?(!AtomQ[#] && #[[1]]==quad&),1]//Flatten;

sextlist = Position[cell,_?(!AtomQ[#] && #[[1]]==sext&),1]//Flatten;
octlist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==oct&),1]//Flatten;
dipkicklist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==dipkick&),1]//Flatten;
quadkicklist  =  Position[cell,_?(!AtomQ[#] && #[[1]]==quadkick&),1]//Flatten;

allkicks = Join[sextlist,octlist,dipkicklist,quadkicklist];
nkicks = Length[allkicks];

If[nkicks ==0,result = tracklin[cellin, endpoint, startvecin];Return[result],

subcell= Take[cell,allkicks[[1]]];


mat= makelattice[subcell,bounds[[allkicks[[1]]]]][[2]];
res = Table[mat.startvec[[n]],{n,1,nvecs}];
mhere = Part[cell,allkicks[[1]],3];
truekick = Which[
Length[Cases[sextlist,allkicks[[1]]]]>0,addsexkick,
Length[Cases[octtlist,allkicks[[1]]]]>0,addoctkick,
Length[Cases[dipkicklist,allkicks[[1]]]]>0,addfixkick,
Length[Cases[quadkicklist,allkicks[[1]]]]>0,addquadkick];
res=Flatten[Map[Take[#,{2}]&,truekick[mhere,res]],1];
Do[

subcell = Take[cell,{allkicks[[ns-1]],allkicks[[ns]]}];
mat= makelattice[subcell,bounds[[allkicks[[ns]]]]-bounds[[allkicks[[ns-1]]]]][[2]];
res = Table[mat.res[[n]],{n,1,nvecs}];
mhere = Part[cell,allkicks[[ns]],3];
truekick = Which[
Length[Cases[sextlist,allkicks[[ns]]]]>0,addsexkick,
Length[Cases[octtlist,allkicks[[ns]]]]>0,addoctkick,
Length[Cases[dipkicklist,allkicks[[ns]]]]>0,addfixkick,
Length[Cases[quadkicklist,allkicks[[ns]]]]>0,addquadkick];
res=Flatten[Map[Take[#,{2}]&,truekick[mhere,res]],1],
{ns ,2,nkicks}];
If[allkicks[[nkicks]] < Length[cell],
subcell = Take[cell,{allkicks[[nkicks]]+1,Length[cell]}];
If[Length[subcell]==1 && subcell[[1,1]]==0,Null,
mat= makelattice[subcell,endpoint-bounds[[allkicks[[nkicks]]]]][[2]];
res = Table[mat.res[[n]],{n,1,nvecs}]]
];
out = Map[List[endpoint,#]&,res];
Return[out];
];
]


(* ::Input::Initialization:: *)
addfixkick[xkick_,startvecin_List]:=Module[{addvec,outvec,endpoint,startvec},
If[IntegerQ[startvecin[[1,1]]],endpoint  = startvecin[[1,1]];startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],endpoint = 0;startvec = startvecin];
addvec = {0,xkick/1000.,0,0,0,0};
outvec = Map[List[endpoint,#]&,Map[Plus[addvec,#]&,startvec]];
Return[outvec];
]


(* ::Input::Initialization:: *)
addsexkick[m_,startvecin_List]:=Module[{addvec,outvec,endpoint,startvec},
If[IntegerQ[startvecin[[1,1]]],endpoint  = startvecin[[1,1]];startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],endpoint = 0;startvec = startvecin];
outvec = Map[List[endpoint,#]&,Map[Plus[{0,m/2*(#[[1]]^2-#[[3]]^2),0,m*#[[1]]*#[[3]],0,0},#]&,startvec]];
Return[outvec];
]


(* ::Input::Initialization:: *)
addoctkick[r_,startvecin_List]:=Module[{addvec,outvec,endpoint,startvec},
If[IntegerQ[startvecin[[1,1]]],endpoint  = startvecin[[1,1]];startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],endpoint = 0;startvec = startvecin];
outvec = Map[List[endpoint,#]&,Map[Plus[{0,r/6*(#[[1]]^3-3*#[[1]]#[[3]]^2),0,r/6*(3*#[[1]]^2*#[[3]]-#[[3]]^3),0,0},#]&,startvec]];
Return[outvec];
]


(* ::Input::Initialization:: *)
addquadkick[kl_,startvecin_List]:=Module[{addvec,outvec,endpoint,startvec},
If[IntegerQ[startvecin[[1,1]]],endpoint  = startvecin[[1,1]];startvec =Flatten[Map[Take[#,{2}]&,startvecin],1],endpoint = 0;startvec = startvecin];
outvec = Map[List[endpoint,#]&,Map[Plus[{0,kl*#[[1]],0,-kl*#[[3]],0,0},#]&,startvec]];
Return[outvec];
]


(* ::Input::Initialization:: *)
pickone[liste_List,n_Integer]:=If[Length[liste[[1,2]]]==0,Chop[Thread[List[Array[#&,Length[liste]],Flatten[Map[Take[#,{n}]&,liste]]]]],Chop[Map[List[#[[1]],#[[2,n]]]&,liste]]];


(* ::Input::Initialization:: *)
Xablage[liste_List] :=pickone[liste,1];
Xprime[liste_List] :=pickone[liste,2];
Yablage[liste_List] :=pickone[liste,3];
Yprime[liste_List] :=pickone[liste,4];
Spos[liste_List] :=pickone[liste,5];
deltap[liste_List] :=pickone[liste,6];



(* ::Input::Initialization:: *)
picktwo[liste_List,n_Integer,m_Integer]:=
If[n==0,pickone[liste,m],
If[Length[liste[[1,2]]]==0,
Chop[ Map[List[#[[n]],#[[m]]]&,liste]],
Chop[ Map[List[#[[2,n]],#[[2,m]]]&,liste]]]];


(* ::Input::Initialization:: *)
Xphase[liste_List] := picktwo[liste,1,2];
Yphase[liste_List] := picktwo[liste,3,4];
Sphase[liste_List] := picktwo[liste,5,6];
Tplane[liste_List] := picktwo[liste,1,3];


(* ::Input::Initialization:: *)
getCoiance[inlist_List]:={Coiance[Xphase[inlist]],Coiance[Yphase[inlist]]};


(* ::Input::Initialization:: *)
getEmittance[inlist_List]:=Block[{covx,covz,epsx,epsz},
covx = Coiance[Xphase[inlist]];
covz = Coiance[Yphase[inlist]];
epsx = Sqrt[Det[covx]];
epsz = Sqrt[Det[covz]];
Return[{epsx,epsz}]
];


(* ::Input::Initialization:: *)
names={"s","x","x'","y","y'","\[Delta]s","\[Delta]p"}


(* ::Input::Initialization:: *)
unitnames = {"[m]","[mm]","[mrad]","[mm]","[mrad]","[mm]",""}


(* ::Input::Initialization:: *)
factors = {1.,1000.,1000.,1000.,1000.,1000.,1.}


(* ::Input::Initialization:: *)
(* PlotBeamdist[inlist_List,n_,m_,opts:OptionsPattern[]]:=ListPlot[(Thread[{factors[[n+1]],factors[[m+1]]} #1]&)/@picktwo[Flatten[inlist,Length[Dimensions[inlist]]-2],n,m],Frame\[Rule]True,FrameLabel\[Rule]{names[[n+1]]<>" "<>unitnames[[n+1]],names[[m+1]]<>" "<>unitnames[[m+1]]},Global`PlotLabel\[Rule]names[[n+1]]<>" \[LongLeftRightArrow] "<>names[[m+1]],Evaluate[FilterRules[{opts}, Options[ListPlot]]]];*)


(* ::Input::Initialization:: *)
(* Options[PlotXphase]= Join[{Global`PlotLabel\[Rule]"horizontal phase space",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotYphase]= Join[{Global`PlotLabel\[Rule]"vertical phase space",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotSphase]= Join[{Global`PlotLabel\[Rule]"longitudinal phase space",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotSXphase]= Join[{Global`PlotLabel\[Rule]"x-s distribution",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotYablage]= Join[{Global`PlotLabel\[Rule]"z-Ablage",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotXablage]= Join[{Global`PlotLabel\[Rule]"x-Ablage",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotXprime]= Join[{Global`PlotLabel\[Rule]"x'-s",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotZprime]= Join[{Global`PlotLabel\[Rule]"z'-s",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotTplane]= Join[{Global`PlotLabel\[Rule]"transverse plane",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];
Options[PlotSpos]= Join[{Global`PlotLabel\[Rule]"longitudinal position",Global`PlotStyle\[Rule]AbsolutePointSize[1]},Options[ListPlot]];*)



(* ::Input::Initialization:: *)
Options[PlotBeamdist]= Options[ListPlot];


(* ::Input::Initialization:: *)
PlotBeamdist[inlist_List,n_,m_,opts:OptionsPattern[]]:=ListPlot[(Thread[{factors[[n+1]],factors[[m+1]]} #1]&)/@picktwo[Flatten[inlist,Length[Dimensions[inlist]]-2],n,m],Frame->True,FrameLabel->{names[[n+1]]<>" "<>unitnames[[n+1]],names[[m+1]]<>" "<>unitnames[[m+1]]},Evaluate[FilterRules[{opts}, Options[ListPlot]]]];


(* ::Input::Initialization:: *)
Options[PlotXphase]= Options[ListPlot];
Options[PlotYphase]=  Options[ListPlot];
Options[PlotSphase]=  Options[ListPlot];
Options[PlotSXphase]=  Options[ListPlot];
Options[PlotYablage]=  Options[ListPlot];
Options[PlotXablage]=  Options[ListPlot];
Options[PlotXprime]=  Options[ListPlot];
Options[PlotYprime]=  Options[ListPlot];
Options[PlotTplane]=  Options[ListPlot];
Options[PlotSpos]=  Options[ListPlot];


(* ::Input::Initialization:: *)
PlotYphase[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,3,4,Global`PlotLabel:>"vertical phase space", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotXphase[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,1,2,Global`PlotLabel:>"horizontal phase space", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotSphase[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,5,6,Global`PlotLabel:>"longitudinal phase space", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotYablage[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,0,3,Global`PlotLabel:>"y-Ablage", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotXablage[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,0,1,Global`PlotLabel:>"x-Ablage", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotSpos[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,0,5,Global`PlotLabel:>"longitudinal position", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
Options[PlotShisto]= Options[Histogram];


(* ::Input::Initialization:: *)
PlotShisto[inlist_List,bspec_:20]:=Histogram[1000*Spos[Flatten[inlist,Length[Dimensions[inlist]]-2]][[All,2]],bspec]


(* ::Input::Initialization:: *)
PlotXprime[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,0,2,Global`PlotLabel:>"x'-s", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotYprime[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,0,4,Global`PlotLabel:>"y'-s", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
PlotTplane[inlist_List,opts:OptionsPattern[]]:=PlotBeamdist[inlist,1,3, Global`PlotLabel:>"transverse plane", Global`PlotStyle:>AbsolutePointSize[1],opts];


(* ::Input::Initialization:: *)
pmod[cellin_List,\[Delta]_]:= Module[{cell,anz,modify,cellnew},
If[IntegerQ[cellin[[1]]],anz=cellin[[1]];
cell=cellin[[2]];
,anz = 1;
cell=cellin;
];
modify[elem_List,\[Delta]]:=Switch[elem[[1]],quad,{quad,elem[[2]],elem[[3]]/(1+\[Delta])},dipol,{dipol,elem[[2]],elem[[3]]*(1+\[Delta])},_,elem];
cellnew = modify[#,\[Delta]]& /@ cell;
Return[{anz,cellnew}]
]


(* ::Input::Initialization:: *)
clearmat[] =ClearAll[prodmat];


(* ::Input::Initialization:: *)
End[]


(* ::Input::Initialization:: *)
EndPackage[]
